version: "3.8"

services:
  landing:
    build: ./landing
    ports:
      - "4000:4000"
    volumes:
      - ./landing:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
      - PORT=4000
    command: [ "npm", "run", "dev" ]

  landing-be:
    build: ./landing-be
    ports:
      - "5050:5050"
    volumes:
      - ./landing-be:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
      - PORT=5050
    command: [ "npm", "run", "start:dev" ]
  
  # PHP service
  php:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: php_app
    volumes:
      - ./php.ini:/usr/local/etc/php/php.ini  # Custom PHP configuration
      - .:/var/www/html  # Mount the project directory
      - ./sessions:/var/lib/php/sessions  # PHP session storage
    working_dir: /var/www/html
    depends_on:
      mysql:
        condition: service_healthy  # Wait for MySQL to be ready before starting
    environment:
      - MYSQL_DATABASE=${MYSQL_DATABASE}
      - MYSQL_USER=${MYSQL_USER}
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}

  # Nginx web server
  nginx:
    image: nginx:latest
    container_name: nginx_server
    ports:
      - "${NGINX_PORT}:80"  # Expose Nginx on a configurable port
    volumes:
      - .:/var/www/html  # Serve project files
      - ./nginx.conf:/etc/nginx/conf.d/default.conf  # Custom Nginx configuration
    depends_on:
      - php  # Ensure PHP service is running first

  # MySQL database
  mysql:
    image: mysql:8.0
    container_name: mysql_container
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    ports:
      - "3306:3306"  # Expose MySQL default port
    volumes:
      - ./storage_data/mysql_data:/var/lib/mysql  # Persist database data
    healthcheck:
      test: [ "CMD", "mysqladmin", "ping", "-h", "localhost" ]
      interval: 30s
      timeout: 10s
      retries: 3  # Ensure MySQL is ready before dependent services start

  # phpMyAdmin for database management
  phpmyadmin:
    image: phpmyadmin/phpmyadmin
    container_name: phpmyadmin_container
    environment:
      PMA_HOST: mysql  # Connect to MySQL container
      PMA_PORT: 3306
    ports:
      - "8081:80"  # phpMyAdmin UI accessible at http://localhost:8081
    depends_on:
      mysql:
        condition: service_healthy  # Wait for MySQL before starting

  #   Redis caching service
  redis:
    image: redis:latest
    container_name: redis_cache
    restart: unless-stopped
    ports:
      - "${REDIS_PORT}:6379"  # Expose Redis
    command: redis-server --appendonly yes  # Enable persistence
    volumes:
      - ./storage_data/redis_data:/data  # Persist Redis data
    healthcheck:
      test: [ "CMD", "redis-cli", "ping" ]
      interval: 30s
      timeout: 5s
      retries: 3
  #
  #  # MeiliSearch - Full-text search engine
  #  meilisearch:
  #    image: getmeili/meilisearch:v1.7
  #    container_name: meilisearch
  #    restart: unless-stopped
  #    environment:
  #      MEILI_MASTER_KEY: ${MEILI_MASTER_KEY}  # Secure API access
  #    ports:
  #      - "7700:7700"
  #    volumes:
  #      - meili_data:/meili_data  # Persist search data
  #
  # Prometheus - Monitoring system
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml  # Custom Prometheus config
    ports:
      - "${PROMETHEUS_PORT}:9090"  # Expose Prometheus
    restart: unless-stopped

  # Grafana - Data visualization for metrics
  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    ports:
      - "3000:3000"  # Access Grafana at http://localhost:3000
    environment:
      GF_SECURITY_ADMIN_USER: ${GRAFANA_ADMIN_USER}
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_ADMIN_PASSWORD}  # Secure access
    volumes:
      - ./storage_data/grafana_data:/var/lib/grafana  # Persist dashboards and settings
    restart: unless-stopped
    depends_on:
      - prometheus  # Ensure Prometheus is running before Grafana starts

  # MinIO - Object storage service (like AWS S3)
  minio:
    image: minio/minio:latest
    container_name: minio
    ports:
      - "9000:9000"  # MinIO API
      - "9091:9090"  # MinIO console UI
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}  # Secure access
    volumes:
      - ./storage_data/minio_data:/data  # Persist stored objects
    command: server --console-address ":9090" /data
    restart: always

  mailhog:
    image: mailhog/mailhog
    container_name: mailhog
    restart: unless-stopped
    ports:
      - "1025:1025" # SMTP server
      - "8025:8025" # Web UI

  #
  #  # RabbitMQ - Message broker for async tasks
  #  rabbitmq:
  #    image: rabbitmq:3-management
  #    container_name: rabbitmq
  #    ports:
  #      - "${RABBITMQ_PORT}:5672"  # Message queue
  #      - "${RABBITMQ_MANAGEMENT_PORT}:15672"  # Management UI
  #    healthcheck:
  #      test: [ "CMD", "rabbitmqctl", "status" ]
  #      interval: 30s
  #      timeout: 10s
  #      retries: 3
  #
  #  # Apache Kafka - Event streaming platform
  #  kafka:
  #    image: confluentinc/cp-kafka
  #    environment:
  #      KAFKA_BROKER_ID: ${KAFKA_BROKER_ID}
  #      KAFKA_ZOOKEEPER_CONNECT: "zookeeper:${ZOOKEEPER_PORT}"
  #      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:${KAFKA_PORT}
  #    ports:
  #      - "${KAFKA_PORT}:9092"  # Expose Kafka
  #    depends_on:
  #      - zookeeper  # Ensure Zookeeper is running first
  #    healthcheck:
  #      test: [ "CMD", "kafka-topics.sh", "--list", "--bootstrap-server", "kafka:${KAFKA_PORT}" ]
  #      interval: 30s
  #      timeout: 10s
  #      retries: 3
  #
  #  # Zookeeper - Required for Kafka
  #  zookeeper:
  #    image: confluentinc/cp-zookeeper
  #    environment:
  #      ZOOKEEPER_CLIENT_PORT: ${ZOOKEEPER_PORT}
  #
  # Portainer - Docker management UI
  portainer:
    image: portainer/portainer-ce:latest
    container_name: portainer
    ports:
      - "8000:8000"  # Edge agent port
      - "9001:9000"  # Web UI
      - "9443:9443"  # Secure UI (HTTPS)
    restart: always
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock  # Grant access to Docker
      - ./storage_data/portainer_data:/data  # Persist Portainer data

  netdata:
    image: netdata/netdata:latest
    container_name: netdata
    pid: host
    cap_add:
      - SYS_PTRACE  # Allow system monitoring
    security_opt:
      - apparmor=unconfined
    restart: always
    ports:
      - "19999:19999"  # Expose Netdata on port 19999
    networks:
      - netdata_network
    volumes:
      - ./storage_data/netdata_data:/var/lib/netdata
      - ./storage_data/netdata_config:/etc/netdata
      - ./storage_data/netdata_cloud:/var/lib/netdata/cloud.d
      - /etc/passwd:/host/etc/passwd:ro
      - /etc/group:/host/etc/group:ro
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /etc/os-release:/host/etc/os-release:ro

  # Nginx Proxy Manager - Reverse proxy with SSL support
  nginx_proxy_manager:
    image: jc21/nginx-proxy-manager:latest
    container_name: nginx_proxy_manager
    restart: always
    networks:
      - proxy_network
    ports:
      - "8071:8071"      # HTTP traffic
      - "443:443"    # HTTPS traffic
      - "81:81"      # Admin panel (http://localhost:81)
    volumes:
      - ./storage_data/nginx_proxy_manager_data:/data
      - ./storage_data/nginx_proxy_manager_letsencrypt:/etc/letsencrypt

  # üöÄ API Gateway (Traefik)
  traefik:
    image: traefik:v2.9
    container_name: traefik
    restart: always
    command:
      - "--api.dashboard=true"
      - "--providers.docker=true"
      - "--providers.file.filename=/etc/traefik/traefik_dynamic.yml"
      - "--entrypoints.web.address=:8080"
      - "--entrypoints.websecure.address=:8443"
      - "--log.level=DEBUG"  # Enable detailed logs for debugging
    ports:
      - "8080:8080"
      - "8443:8443"
    networks:
      - backend
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ./traefik_dynamic.yml:/etc/traefik/traefik_dynamic.yml
      - ./letsencrypt:/letsencrypt

  # üñ•Ô∏è Authentication & Identity (Keycloak)
  keycloak:
    image: quay.io/keycloak/keycloak:latest
    container_name: keycloak
    command: [ "start-dev" ]
    environment:
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://postgres/keycloak
      KC_DB_USERNAME: keycloak
      KC_DB_PASSWORD: keycloakpassword
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: adminpassword
    depends_on:
      postgres:
        condition: service_healthy  # Wait until PostgreSQL is healthy
    ports:
      - "8181:8080"
    networks:
      - backend

  postgres:
    image: postgres:15
    container_name: postgres
    restart: always
    environment:
      POSTGRES_DB: keycloak
      POSTGRES_USER: keycloak
      POSTGRES_PASSWORD: keycloakpassword
    volumes:
      - ./storage_data/postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: [ "CMD", "pg_isready", "-U", "keycloak" ]
      interval: 10s
      retries: 5
    networks:
      - backend
  #
  #    # üîß Core Backend (Rails)
  #  rails:
  #    image: ruby:3.2-alpine  # Lightweight official Ruby image
  #    container_name: rails_backend
  #    depends_on:
  #      - postgres
  #      - redis
  #    environment:
  #      DATABASE_URL: postgres://root:rootpassword@postgres:5432/app_db
  #      REDIS_URL: redis://redis:6379/1
  #    networks:
  #      - backend
  #    volumes:
  #      - ./rails-backend:/app
  #    working_dir: /app  # Set working directory
  #    command: [ "sh", "-c", "bundle install && rails server -b 0.0.0.0 -p 3030" ]
  #    ports:
  #      - "3030:3030"
  #
  #  # üì° Real-Time Communication (Node.js + WebSockets)
  #  websocket:
  #    image: node:18-alpine  # Lightweight official Node.js image
  #    container_name: websocket_service
  #    command: [ "node", "server.js" ]  # Start the WebSocket server
  #    depends_on:
  #      - redis
  #    networks:
  #      - backend
  #    ports:
  #      - "3001:3001"
  #    volumes:
  #      - ./node-realtime:/app
  #    working_dir: /app  # Set working directory
  #    environment:
  #      - REDIS_HOST=redis
  #      - REDIS_PORT=6379
  #
  # üî• AI & ML Processing (Python + FastAPI)
  ai_service:
    build:
      context: ./python-ai
    container_name: ai_service_container
    #    depends_on:
    #      - clickhouse
    #      - keycloak
    #    environment:
    #      - KEYCLOAK_URL=http://keycloak:8080
    #      - KEYCLOAK_REALM=fastapi-realm
    #      - KEYCLOAK_CLIENT_ID=fastapi-client
    #      - KEYCLOAK_CLIENT_SECRET=your-client-secret
    ports:
      - "5001:5001"
    networks:
      - backend
    volumes:
      - ./python-ai:/app

  # üìä Analytics Database (ClickHouse)
  clickhouse:
    image: clickhouse/clickhouse-server
    restart: always
    ports:
      - "8123:8123"  # HTTP Interface
      - "9000:9000"  # Native Client
    volumes:
      - ./storage_data/clickhouse_data:/var/lib/clickhouse
    environment:
      CLICKHOUSE_DB: default
      CLICKHOUSE_USER: admin
      CLICKHOUSE_PASSWORD: admin

  tabix:
    image: spoonest/clickhouse-tabix-web-client
    container_name: tabix
    restart: always
    ports:
      - "8082:80"  # Tabix UI accessible on http://localhost:8081
    depends_on:
      - clickhouse

#
#  # üöÄ Payment Processing (Go + gRPC)
#  payments:
#    image: golang:1.21-alpine  # Lightweight official Go image
#    container_name: payments_service
#    command: [ "go", "run", "main.go" ]  # Runs your gRPC server
#    networks:
#      - backend
#    ports:
#      - "6000:6000"
#    volumes:
#      - ./go-payments:/app
#    working_dir: /app  # Set working directory
#    environment:
#      - DATABASE_URL=mysql://user:password@tcp(mysql:3306)/payments_db
#
networks:
  backend:
    driver: bridge
  #  frontend:
  #    driver: bridge
  #  databases:
  #    driver: bridge
  netdata_network:
    driver: bridge
  proxy_network:
    driver: bridge
#
#volumes:
#  mysql_data:  # Stores MySQL database data to ensure persistence
#  redis_data:  # Stores Redis cache data (if used for caching)
#  meili_data:  # Stores MeiliSearch index and search data
#  grafana_data:  # Stores Grafana dashboards and analytics configurations
#  minio_data:  # Stores MinIO object storage data (similar to AWS S3)
#  portainer_data:  # Stores Portainer UI settings and Docker management data
#  netdata_data:  # Stores Netdata system monitoring logs and metrics
#  nginx_proxy_manager_data:  # Stores Nginx Proxy Manager settings and configurations
#  nginx_proxy_manager_letsencrypt:  # Stores SSL certificates managed by Nginx Proxy Manager
